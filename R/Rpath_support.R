########################################################################################
# Set of functions for returning functional group names (character vector)
# using the type input column
#
# Internal supporting function for group names to check type 
gtype <- function(Rpath){
  if(class(Rpath)=="Rpath"){gt<-list(type=Rpath$type, grp=Rpath$Group)}
  else{
    if(class(Rpath)=="Rpath.params"){
      gt<-list(type=Rpath$model$Type, grp=Rpath$model$Group)}
    else{
      stop("Input must be an Rpath (balanced) or Rpath.params (unbalanced) object.")
    }
  }
  names(gt$type)<-NULL; names(gt$grp)<-NULL
  return(gt)
}
####################################
#' Rpath functional group names
#' 
#' Get a character vector of functional group names from an Rpath object (balanced model)  
#' or an Rpath.params object (unbalanced model parameters) based on the 'type' input
#' parameter as follows: (0: consumers, 1: producers, 2: detrital, 3: gears, 0<type<1: mixotrophs).
#' Living groups are consumers + producers.  Note that mixotrophs are not returned as
#' either consumers or producers, only separately.  
#' 
#'@name rpath.groups
#' 
#'@family Rpath functions
#'
#'@param Rpath Balanced Rpath model generated by rpath.
#'
#'@return Returns a character vector containing the names of Rpath functional groups
#'by category (group type).
#'
#'@export
rpath.groups     <- function(Rpath){gt<-gtype(Rpath); return(gt$grp) }

#'@rdname rpath.groups
#'@export
rpath.living     <- function(Rpath){gt<-gtype(Rpath); return(gt$grp[gt$type<2]) }

#'@rdname rpath.groups
#'@export 
rpath.detrital   <- function(Rpath){gt<-gtype(Rpath); return(gt$grp[gt$type==2])}

#'@rdname rpath.groups
#'@export 
rpath.gears      <- function(Rpath){gt<-gtype(Rpath); return(gt$grp[gt$type==3])}

#'@rdname rpath.groups
#'@export 
rpath.producers  <- function(Rpath){gt<-gtype(Rpath); return(gt$grp[gt$type==1]) }

#'@rdname rpath.groups
#'@export 
rpath.consumers  <- function(Rpath){gt<-gtype(Rpath); return(gt$grp[gt$type==0])}

#'@rdname rpath.groups
#'@export 
rpath.mixotrophs <- function(Rpath){gt<-gtype(Rpath); return(gt$grp[gt$type>0 & gt$type<0])}

#################################################################################
#' Extract start and end states from an rsim run output.
#' 
#' Extract the starting or ending biomass or catch from the output of an rsim run.
#'
#'@name RsimEndpoints
#'
#'@family Rpath functions
#'
#'@param Rsim.output An Rsim output object generated by rsim.run or rsim.step.
#'
#'@return Returns a named vector of starting or ending biomass or catch.
NULL

#'@rdname RsimEndpoints 
#'@export 
starting.biomass <- function(Rsim.output){
  return(Rsim.output$out_Biomass[1, 2:(dim(Rsim.output$out_Biomass)[2])])
}

#'@rdname RsimEndpoints 
#'@export 
ending.biomass <- function(Rsim.output){
  return(Rsim.output$out_Biomass[dim(Rsim.output$out_Biomass)[1], 2:(dim(Rsim.output$out_Biomass)[2])])
}

#'@rdname RsimEndpoints 
#'@export 
starting.catch <- function(Rsim.output){
  return(Rsim.output$out_Catch[1, 2:(dim(Rsim.output$out_Catch)[2])])
}

#'@rdname RsimEndpoints 
#'@export 
ending.catch <- function(Rsim.output){
  return(Rsim.output$out_CC[dim(Rsim.output$out_Catch)[1], 2:(dim(Rsim.output$out_Catch)[2])])
}



###############################################################################

#'@export
rsim.deriv.q <- function(Rpath.scenario, year=0, month=0, tstep=0){
  scene <- copy(Rpath.scenario)
  rout <- deriv_vector(scene$params,  scene$start_state, 
                       scene$forcing, scene$fishing,
                       scene$stanzas, year, month, tstep)
  
  rtab <- data.frame(scene$params$spname[scene$params$PreyTo+1], 
                     scene$params$spname[scene$params$PreyFrom+1],
                     rout$Qlink)
  colnames(rtab)<-c("Predator","Prey","Q")
  return(rtab)
}

###############################################################################
#'@export
get.rsim.predprey <- function(scene,predator="all",prey="all"){  
  pd <- scene$params$spname[scene$params$PreyTo+1]
  py <- scene$params$spname[scene$params$PreyFrom+1]
  if (predator=="all") predator <- scene$params$spname
  if (prey=="all")     prey     <- scene$params$spname
  link <- which((pd %in% predator) & (py %in% prey))
  predname <- pd[link]
  preyname <- py[link]
  QQ <- scene$params$QQ[link]
  DD <- scene$params$DD[link]
  VV <- scene$params$VV[link]
  PredPredWeight <- scene$params$PredPredWeight[link]
  PreyPreyWeight <- scene$params$PreyPreyWeight[link]
  HandleSwitch <- scene$params$HandleSwitch[link]
  return(data.frame(link,predname,preyname,QQ,VV,DD,
                    HandleSwitch,PredPredWeight,PreyPreyWeight))
}  

###############################################################################
#'@export
get.rsim.predprey.link <- function(scene,predator="all",prey="all"){  
  pd <- scene$params$spname[scene$params$PreyTo+1]
  py <- scene$params$spname[scene$params$PreyFrom+1]
  if (predator=="all") predator <- scene$params$spname
  if (prey=="all")     prey     <- scene$params$spname
  link <- which((pd %in% predator) & (py %in% prey))
  return(link)
}  

###############################################################################
#'@export
adjust.rsim.predprey <- function(scene,parameter,
                                 predator="all",prey="all",values){  
  pd <- scene$params$spname[scene$params$PreyTo+1]
  py <- scene$params$spname[scene$params$PreyFrom+1]
  if (predator=="all") predator <- scene$params$spname
  if (prey=="all")     prey     <- scene$params$spname
  link <- which((pd %in% predator) & (py %in% prey))
  
  if (parameter %in% c('QQ', 'VV', 'DD', 'HandleSwitch', 'PredPredWeight', 
                       'PreyPreyWeight')){
    scene$params[[parameter]][link] <- values
  }
  else {(warning(parameter," is not a valid predator/prey parameter."))}
  
  return(scene)
}   

###############################################################################



